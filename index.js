// Generated by CoffeeScript 1.6.3
var SKIP, all, asSeq, changedBetween, empty, filterM, git, join, log, logSeq, map, previousCommitsSeq, produced, reduced, resolve, series, treeEntry, window, _ref, _ref1;

git = require('gitteh-promisified');

_ref = require('kew'), all = _ref.all, resolve = _ref.resolve;

_ref1 = require('reduced'), SKIP = _ref1.SKIP, asSeq = _ref1.asSeq, produced = _ref1.produced, reduced = _ref1.reduced, join = _ref1.join, series = _ref1.series, map = _ref1.map, empty = _ref1.empty, window = _ref1.window;

filterM = function(seq, f) {
  seq = asSeq(seq);
  return {
    next: function(done) {
      return seq.next(function(s, v) {
        if (s != null) {
          return done(s);
        }
        return reduced(asSeq(f(v))).then(function(allowed) {
          if (allowed) {
            return done(null, v);
          } else {
            return done(SKIP);
          }
        }).end();
      });
    }
  };
};

treeEntry = function(tree, path) {
  var entry, _i, _len, _ref2;
  if (!Array.isArray(path)) {
    path = path.split('/').filter(Boolean);
  }
  _ref2 = tree.entries;
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    entry = _ref2[_i];
    if (entry.name === path[0]) {
      if (path.length === 1 && entry.type === 'blob') {
        return resolve(entry);
      } else if (path.length > 1 && entry.type === 'tree') {
        return tree.repository.tree(entry.id).then(function(tree) {
          return treeEntry(tree, path.slice(1));
        });
      }
    }
  }
  return resolve(void 0);
};

changedBetween = function(path, commit, prevCommit) {
  if (prevCommit != null) {
    return all(commit.tree(), prevCommit.tree()).then(function(_arg) {
      var prevTree, tree;
      tree = _arg[0], prevTree = _arg[1];
      return all(treeEntry(tree, path), treeEntry(prevTree, path)).then(function(_arg1) {
        var changed, created, entry, prevEntry;
        entry = _arg1[0], prevEntry = _arg1[1];
        created = entry && !prevEntry;
        changed = (entry != null ? entry.id : void 0) !== (prevEntry != null ? prevEntry.id : void 0);
        return changed || created;
      });
    });
  } else {
    return commit.tree().then(function(tree) {
      return treeEntry(tree, path);
    }).then(function(entry) {
      return entry != null;
    });
  }
};

previousCommitsSeq = function(commit) {
  var getCommit, getPreviousCommit;
  getCommit = function(id) {
    return commit.then(function(commit) {
      return commit.repository.commit(id);
    });
  };
  getPreviousCommit = function(commit) {
    var parents;
    if (commit.parents.length > 0) {
      parents = map(commit.parents, getCommit);
      return join(map(parents, previousCommitsSeq));
    } else {
      return empty();
    }
  };
  return join(series(getPreviousCommit, commit));
};

logSeq = function(ref, file) {
  var commit, commits;
  commit = ref.repository.commit(ref.target);
  if (file != null) {
    commits = previousCommitsSeq(commit);
    commits = window(commits, 2);
    commits = filterM(commits, function(_arg) {
      var commit, prevCommit;
      commit = _arg[0], prevCommit = _arg[1];
      return changedBetween(file, commit, prevCommit);
    });
    return commits = map(commits, function(_arg) {
      var commit, prevCommit;
      commit = _arg[0], prevCommit = _arg[1];
      return commit;
    });
  } else {
    return previousCommitsSeq(commit);
  }
};

log = function(ref, file) {
  return produced(logSeq(ref, file));
};

module.exports = {
  log: log,
  logSeq: logSeq,
  previousCommitsSeq: previousCommitsSeq
};
